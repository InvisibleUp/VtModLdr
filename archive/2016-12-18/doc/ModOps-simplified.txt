This is a listing of what every operation actually DOES, stripping out implementation details and other boilerplate
If the return value of a function is BOOL, it returns TRUE unless an error occurs or it otherwise explicitly returns FALSE.

struct ModSpace Mod_GetPatchInfo(json_t *patchCurr, const char *ModPath);
	(If not listed, assume value is ripped directly from JSON)
		
	(ID)
	if(input.Start is UUID && !input.ID):
		input.ID = input.Start;
	elif(input.Start is number && !input.ID):
		input.ID = input.FileID + "-" + input.Start;

	(Start, End)
	if(input.Start is UUID):
		input.Start = (Given UUID).Start
		input.End = (Given UUID).End
	elif(input.Start is number && input.FileType == PE):
		input.Start (PE) -> (Offset)
		input.End (PE) -> (Offset)

	assert(input.Start and input.End are in range of input.File)

	(Bytes, Len, SrcStart, SrcEnd)
	if(Mode == Move || Move == Copy):
		(For SrcStart, SrcEnd do same as Start, End)
		Bytes = (contents of SrcFile from SrcStart to SrcEnd)
		Len = len(Bytes)
	elif(Mode == Add || Mode == Repl):
		if(ByteMode == "Bytes"):
			input.Bytes = (given bytes)
			input.len = len(given bytes)
		elif(ByteMode == "UUIDPointer"):
			input.Bytes == (start address of given ID)
			input.Bytes += (given offset (+ or - after ID))
			input.len = 4
		elif(ByteMode == "VarValue"):
			input.Bytes = (value of given variable)
			input.len = (size of given variable)

ModOp_Split:

ModOp_Split function definition pending...

	BOOL Mod_SplitSpace(struct ModSpace *out, const char *HeadID, const char *TailID, const char *OldID, const char *ModUUID, int splitOff, BOOL retHead);

		var = Variable to write position data back to. Optional (can be NULL)
		HeadID = UUID of space before split
		TailID = UUID of space after split
		OldID = UUID of space being split (fail on cross-space split?)
		splitOff = Location of split, offset from OldID.start
		retHead = If TRUE, write position of Head into var on return. Otherwise, write position of Tail.
		[xyz] = Values from (out) (or Old. Doesn't matter.)

		assert(HeadID != TailID)
		if(HeadID == OldID):
			OldID += "~oldx" (SQL, not local)
		elif(TailID == OldID):
			OldID += "~oldx" (SQL, not local)

		SQL: ID     | Type     | File   | Mod   | Start        | End                  | Len      | UsedBy
		     HeadID   Old.type   [File]   [Mod]   Old.start      Old.start + splitOff   (Len)      [UsedBy]
		     TailID   Old.type   [File]   [Mod]   Head.end + 1   Old.end                (Len)      [UsedBy]
		     OldID    SPLIT      [File]   [Mod]   HeadID         TailID                 Old.len    [UsedBy]

		if(retHead):
			out.Start = Old.start
			out.End = Old.start + splitOff
		else:
			out.Start = Old.start + splitOff + 1
			out.End = Old.end

ModOp_Merge:

ModOp_Merge function definition pending...

	BOOL Mod_MergeSpace(struct VarValue var, const char *HeadID, const char *TailID, const char *ModUUID);

		if(var.ID was autogenerated from number):
			var.ID = HeadID + "-" + TailID
		assert(Head.type == Tail.type)
		assert(Head.type != MERGE && Head.type != SPLIT && Tail.type != MERGE && Tail.type == SPLIT)

		HeadID -> HeadID~oldx (in SQL and locally)
		TailID -> TailID~oldx

		SQL: ID          | Type      | File   | Mod   | Start      | End       | Len   | UsedBy
		     var.ID~oldx   MERGE       [File]   [Mod]   HeadID       TailID      0       [UsedBy]
		     var.ID        Head.Type   [File]   [Mod]   Head.start   Tail.end    (Len)   [UsedBy]

ModOp_Add:

BOOL ModOp_Add(struct ModSpace input, const char *ModUUID);

	FreeSpace = Mod_FindSpace (Finds empty space with len (len) in range (start)-(end))

	if(FreeSpace.len > input.len && input.ID != FreeSpace.ID):
		Mod_SplitSpace(&input, FreeSpace.ID, input.ID, FreeSpace.ID, input.len, TRUE);
	elif(FreeSpace.len > input.len):
		(Patch is adding to named clear space)
		Mod_SplitSpace(
			&input, #ModSpace
			input.ID, # Head
			FreeSpace.ID + "~overflow", # Tail
			FreeSpace.ID, #Patch ID
			input.len, # SplitOff
			TRUE # Return head?
		);

	BOOL Mod_AddSpace(struct ModSpace input, const char *ModUUID);

		(This function is simply concerned with adding a space, regardless of legality)

		if(input.File is a PE):
			File_OffToPE(input.File, input.Start)
			File_OffToPE(input.File, input.End)

		SQL: ID       | Type | File       | Mod     | Start       | End       | Len       | UsedBy
		     input.ID   ADD    input.File   ModUUID   input.Start   input.End   input.Len   ModUUID

	if(input.File == ":memory:"):
		(Can't do anything more with a file that doesn't exist.)
		return TRUE;

	if(input.End > len(input.File)):
		(We're appending. Hopefully intentionally. Fill new space with 0s.)
		input.file.append(0, len(input.File) - input.End);

	SQL (Revert): PatchUUID | OldBytes
	              input.ID  | (contents of input.File from input.Start to input.End)

	(Write to input.File the value of input.Bytes from input.Start to input.End)

ModOp_Clear:

BOOL ModOp_Clear(struct ModSpace input, const char *ModUUID);

	(There was, at one point in time, a check to see if the space to be cleared was occupied by a mod.)
	(I have since decided that doing so would be rather useless as that's sort of the job of CLEAR.)
	(Besides, carpet-bomb CLEARs don't really happen, short of pruning unused stuff.)

	if(input is within another space):
		if(input.Start != parentSpace.start):
			Mod_SplitSpace(
				input, #ModSpace
				parentSpace.ID + "~old", # Head
				input.ID, # Tail
				parentSpace.ID, #Patch ID
				input.Start, # SplitOff
				FALSE # Return head?
			);
		
		if(input.End != parentSpace.end):
			Mod_SplitSpace(
				input, #ModSpace
				input.ID, # Head
				parentSpace.ID + "~overflow", # Tail
				parentSpace.ID, #Patch ID
				input.Start, # SplitOff
				TRUE # Return head?
			);
			
	
	SQL: ID       | Type | File       | Mod     | Start       | End       | Len       | UsedBy
	     input.ID   CLEAR  input.File   ModUUID   input.Start   input.End   input.Len   ModUUID

	(New: overwrite cleared space with 0x0F0B on PE (x86 undefined operation) or 0xFF otherwise.)
	(If a program jumps to a freed space, it will immediately crash.)

	
	if(input.End > len(input.File)):
		(...wut?)
		input.End = len(input.File);
	if(input.Start > len(input.File)):
		(Not sure if or when this would happen.)
		return TRUE;

	SQL (Revert): PatchUUID | OldBytes
	              input.ID  | (contents of input.File from input.Start to input.End)

	(Write to input.File value 0x0F0B or 0xFF repeating from input.Start to input.End)

ModOp_Reserve:

BOOL ModOp_Reserve(struct ModSpace input, const char *ModUUID);

	(Essentially ModOp_Add without the Revert table addition or the write)
	
	FreeSpace = Mod_FindSpace (Finds empty space with len (len) in range (start)-(end))

	if(FreeSpace.len > input.len && input.ID != FreeSpace.ID):
		Mod_SplitSpace(input, FreeSpace.ID, input.ID, FreeSpace.ID, input.len, TRUE);
	elif(FreeSpace.len > input.len):
		(Patch is adding to named clear space)
		Mod_SplitSpace(input, FreeSpace.ID + "~oldx", input.ID, FreeSpace.ID, input.len, TRUE);
		
	Mod_AddSpace(struct ModSpace input, const char *ModUUID); (See ModOp_Add for details)

ModOp_Copy:
	Doesn't exist; ModOp_Add is used instead.

ModOp_Move:
	Doesn't actually exist; code is in mode dispatcher in Mod_Install.
	
	(Clear SrcStart-SrcEnd. This is done by making a duplicate of input, setting start and end to
	the values of SrcStart and SrcEnd, and executing ModOp_Clear(input, srcInput))

	ModOp_Add(input, ModUUID)

---

SQL Reference:
	REMOVE: Obliterate table row
	RESTORE: Obliterate table row.
	         Rename "~oldx" from given ID with highest value of x to given ID (if possible)

ModOp_UnSplit:

	SQL: REMOVE HeadID, TailID
	     RESTORE input.ID

ModOp_UnMerge:

	SQL: RESTORE input.ID

ModOp_UnSpace:

	Used for ADD and CLEAR spaces, as they are mostly identical

	Revert bytes from Revert table and remove entry.
	SQL: RESTORE input.ID